<!DOCTYPE html>
<html>

<head>
    <title>Portfolio</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.css">
    </link>
    <link rel="stylesheet" href="projects.css">
    <style>

    </style>
</head>

<body>

    <div id="navbar">
        <div class="dropdown">
            <a href="#" class="dropbtn">Home</a>
            <div class="dropdown-content">
                <a href="index.html">Home</a>
                <a href="project2_task1.html">Task 1</a>
                <a href="project2_task3.html">Task 3</a>
            </div>
        </div>
        <a href="">Project 3 <i class="fa fa-person-rays"></i></a>
        <a href="https://github.com/Betsalely/Portfolio/tree/main" target="_blank">Github Repo <i
                class="fa-brands fa-github"></i></a>
    </div>
    <div class="main">
        <div class="start">
            <h1>Task 2 - Floor moving</h1>
            <h2 id="title">Development</h2>
            <br>
            <br>
            <br>
            <br>
            <div id="loremIp" style="padding:50px 10px;width:49%; min-height: 150px; font-size: 20px;">With felix making
                the floor a gradient it makes this step so much easier. The steps basically include making a variable
                called floor_pattern. This variable is an array for the different R (RGB) values between 0 and 255 in
                increments of specific values based on how many columns we have. It does this by making a one line 'for'
                loop which is not easy to read for most beginner programmers, but since this is the last tweak the floor
                requires it's fine. Then whenever the old create_floor() function was called (now named draw_floor()) it
                would instead call the move_floor() function which updates our floor pattern, and then redraws the floor
                with our new pattern. This gives the illusion that the player is moving while in reality the player
                stays in the same x position the whole game.</div>
            <div class="polyimg" style="margin-top:-220.5px; float: right; width:49%; "><img
                    src="./images/moving_floors.png" id="image-disp"></div>







        </div>




    </div>
    <button onclick="lastSlide()" class="arrow leftarrow"><i class="fa fa-arrow-left"></i></button>
    <button onclick="nextSlide()" class="arrow rightarrow"><i class="fa fa-arrow-right"></i></button>





    <script>

        let slide = 0
        function nextSlide() {
            var title = document.getElementById('title');
            var loremIp = document.getElementById('loremIp');
            var image = document.getElementById('image-disp');

            if (slide === 0) {
                slide++;
                // slide 1
                title.innerText = "Development";
                loremIp.innerText = "With felix making the floor a gradient it makes this step so much easier. The steps basically include making a variable called floor_pattern. This variable is an array for the different R (RGB) values between 0 and 255 in increments of specific values based on how many columns we have. It does this by making a one line 'for' loop which is not easy to read for most beginner programmers, but since this is the last tweak the floor requires it's fine. Then whenever the old create_floor() function was called (now named draw_floor()) it would instead call the move_floor() function which updates our floor pattern, and then redraws the floor with our new pattern. This gives the illusion that the player is moving while in reality the player stays in the same x position the whole game.";
                image.setAttribute('src', './images/moving_floors.png');
            } else if (slide === 1) {
                slide++;
                // slide 2
                title.innerText = "Testing";
                loremIp.innerText = "The only way to test a visual code like this is to run it. When I did it seemed to work perfectly almost immediatley. I ran the program for about 30 seconds and there seemed to be no issues. This function was straight forward and while the solution did require some clever coding and array manipulation. A lot of the code relies on the 'floor_pattern = [((col * 18)%256,0,0) for col in range(col_count)]'. This lines just makes an array of different rgb values from black to red depending on how many columns there are. Then the floor moving is literally just changing that array around. While some of the syntax may look a bit confusing since this is the last piece of code to do with this area its fine It won't need further changes.";
                image.setAttribute('src', './images/moving_floor_testing.png');
            } else if (slide === 2) {
                slide = 0;
                // slide 0
                title.innerText = "Improvements";
                loremIp.innerText = "In summary we hit the nail on the head with this one. There were no apparent issues and even with death detection (task 3) it works pefectly. There were no required changes or improvements made. ";
                image.setAttribute('src', './images/moving_floor_testing.png');
            }
        }


        function lastSlide() {
            var title = document.getElementById('title');
            var loremIp = document.getElementById('loremIp');
            var image = document.getElementById('image-disp');

            if (slide === 0) {
                slide = 2;
                // slide 0
                title.innerText = "Improvements";
                loremIp.innerText = "In summary we hit the nail on the head with this one. There were no apparent issues and even with death detection (task 3) it works pefectly. There were no required changes or improvements made. "
                image.setAttribute('src', './images/moving_floor_testing.png');
            } else if (slide === 2) {
                slide = 1;
                // slide 2
                title.innerText = "Testing";
                loremIp.innerText = "The only way to test a visual code like this is to run it. When I did it seemed to work perfectly almost immediatley. I ran the program for about 30 seconds and there seemed to be no issues. This function was straight forward and while the solution did require some clever coding and array manipulation. A lot of the code relies on the 'floor_pattern = [((col * 18)%256,0,0) for col in range(col_count)]'. This lines just makes an array of different rgb values from black to red depending on how many columns there are. Then the floor moving is literally just changing that array around. While some of the syntax may look a bit confusing since this is the last piece of code to do with this area its fine It won't need further changes. The game speed was approved by three different people (Troy, Charlie and Roy). ";
                image.setAttribute('src', './images/moving_floor_testing.png');
            } else if (slide === 1) {
                slide = 0;
                // slide 1
                title.innerText = "Development";
                loremIp.innerText = "With felix making the floor a gradient it makes this step so much easier. The steps basically include making a variable called floor_pattern. This variable is an array for the different R (RGB) values between 0 and 255 in increments of specific values based on how many columns we have. It does this by making a one line 'for' loop which is not easy to read for most beginner programmers, but since this is the last tweak the floor requires it's fine. Then whenever the old create_floor() function was called (now named draw_floor()) it would instead call the move_floor() function which updates our floor pattern, and then redraws the floor with our new pattern. This gives the illusion that the player is moving while in reality the player stays in the same x position the whole game.";
                image.setAttribute('src', './images/moving_floors.png');
            }
        }


    </script>

</body>

</html>